= Cross-building =

== Introduction ==

Different versions of Scala are often binary incompatible between versions, despite maintaining source compatibility.  This is true even for versions with the same minor number, such as 2.7.3 and 2.7.4.  This page describes how to use `sbt` to build and publish your project against multiple versions of Scala and how to use libraries that have done the same.

== Publishing Conventions ==

The underlying mechanism used to indicate which version of Scala a library was compiled against is to append `_<scala-version>` to the library's name.  For example, `dispatch` becomes `dispatch_2.7.5` for the variant compiled against Scala 2.7.5.  This allows interoperability with users of Maven, Ant and other build tools.

The rest of this page describes how `sbt` handles this for you as part of cross-building.

== Using Cross-Built Libraries ==

To use a library built against multiple versions of Scala, double the first `%` in an inline dependency to be `%%`.  This tells `sbt` that it should append the current version of Scala being used to build the library to the dependency's name.  For example:
{{{
  val dispatch = "net.databinder.dispatch" %% "dispatch" % "0.5.2"
}}}

A nearly equivalent, manual alternative is:
{{{
  val dispatch = "net.databinder.dispatch" % ("dispatch_" + crossScalaVersionString) % "0.5.2"
}}}
Or, for a fixed version of Scala:
{{{
  val dispatch = "net.databinder.dispatch" % "dispatch_2.7.5" % "0.5.2"
}}}

== Cross-Building a Project ==

Define the versions of Scala to build against by overriding the `crossScalaVersions` method.  For example:
{{{
  override def crossScalaVersions = Set("2.7.2", "2.7.3", "2.7.4", "2.7.5", "2.7.6")
}}}
The versions specified must be supported by `sbt`.  When you run an action, `sbt` will still use the version of Scala defined in the `scala.version` property.  To build against all versions listed in `crossScalaVersions`, prefix the action to run with `+`.  For example:
{{{
> +package
}}}
A typical way to use this feature is to do development on a single Scala version (no `+` prefix) and then cross-build (using `+`) occasionally and when releasing.  The ultimate purpose of `+` is to cross-publish your project.  That is, by doing:
{{{
> +publish
}}}
you make your project available to users with different versions of Scala.  See [Publishing] for more details on publishing your project.

When `crossScalaVersions` is defined, different output and managed dependency directories are used for different versions of Scala.  For example, when building against Scala 2.7.5,
 * `./lib_managed/` becomes `./lib_managed/scala_2.7.5/
 * `./target/` becomes `./target/scala_2.7.5/`
Packaged jars, wars, and other artifacts have `_<scala-version>` appended to the normal artifact ID as mentioned in the Publishing Conventions section above.  This is the case regardless of whether an action is prefixed by `+`.

This means that the outputs of each build against each version of Scala are independent of the others.  Note that you need to run `+update` if you are using managed dependencies so that `sbt` can resolve your dependencies for each version separately.  This way you would get the version of Dispatch compiled against 2.7.5 for your 2.7.5 build, the version compiled against 2.7.4 for your 2.7.4 build, and so on.  In fact, you can control your dependencies for different Scala versions.  For example:

{{{
  val scalatest =
    ScalaVersion.currentString match {
      case "2.7.5" => "org.scala-tools.testing" % "scalatest" % "0.9.5"
      case "2.7.2" => "org.scalatest" % "scalatest" % "0.9.3"
      case x => error("Unsupported Scala version " + x)
    }
}}}

This works because your project definition is recompiled against each version of Scala you are building against and then reloaded for each version.  `ScalaVersion.currentString` contains the current version of Scala being used to build the project.