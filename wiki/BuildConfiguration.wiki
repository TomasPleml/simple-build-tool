= Introduction =

This page describes build configuration for when the default actions or paths are not sufficient or appropriate for your project.

<wiki:toc max_depth="2" />

= Example =

As of `sbt` 0.4.5, if you only have one main class in your project, sbt will detect it automatically.  This class will be run when the `run` action is executed and will be the value of the `Main-Class` attribute for the `package` action.  If you have more than one main class, you need to specify the main class to use explicitly.  This example will show you how to do this.

First, create a new project:
{{{
$ sbt
Project does not exist, create new project? (y/N) : y
Name: Test Project
...
}}}

Make a source file called

{{{
src/main/scala/Test.scala
}}}

with the following content:

{{{
object Test
{
  def main(args: Array[String])
  {
    println("Hello World! " + args.mkString(" "))
  }
}
}}}

Now, run it:
{{{
$sbt
> run
...
Hello World!
...
}}}

{{{
$sbt
> run (again)
...
Hello World! (again)
...
}}}

When you execute the `run` action, `sbt` runs `Test` using the scala runner in the same virtual machine as `sbt` (see RunningProjectCode for details).  Now, add another source file

{{{
src/main/scala/Test2.scala
}}}

with a main method:

{{{
object Test2
{
  def main(args: Array[String])
  {
    println("Hello World 2! " + args.mkString(" "))
  }
}
}}}

If you try `run`, you are prompted for which one to run:

{{{
Multiple main classes detected, select one to run:

 [1] Test2
 [2] Test

Enter number:
}}}

Explicitly specify the main class by configuring your build.  Do this by creating a new file called
{{{
project/build/src/TestProject.scala
}}}

with the following content:

{{{
import sbt._

class TestProject(info: ProjectInfo) extends DefaultProject(info)
{
  override def mainClass = Some("Test")
}
}}}

This build configuration is referred to as your project definition.  If you have `sbt` running, you need to reload the project with the new project definition:
{{{
> reload
}}}
Otherwise, start up sbt and execute `run`.  `sbt` will run the requested class without prompting.  In addition, `package` will know which main class to use for the `Main-Class` attribute in the manifest (it will not add a `Main-Class` attribute if multiple main classes exist and one is not specified explicitly).

= Configuration Details =

`sbt` only recompiles a project definition on startup or when invoking the interactive command `reload`.  Therefore, if you are running in interactive mode, invoke `reload` after making changes to your project definition for the changes to take effect.

The `project/build` directory is a project itself.  Therefore, you can add jars to the `project/build/lib` directory to use from your project definition.  You can also have multiple sources for your project definition.  The only requirement is there must be exactly one public, concrete subclass of `Project` with a constructor that accepts a `ProjectInfo` instance.  `sbt` finds this subclass when it compiles the project definition, so the names of source files are not important.

= Specifying Options =

Setting the main class was one case of specifying options for tasks (in that case, the `run` task).  The general mechanism for specifying options is with an overridable method that defines the list of options for a task.  For example, the default options for the `compile` task are defined as:

{{{
    def compileOptions: Seq[CompileOption] = Deprecation :: Nil
}}}

`Deprecation` is a val in `ScalaProject` that is an instance of `CompileOption` and represents the command line `scalac` option `-deprecation`.  To additionally specify the `-unchecked` command line option, override `compileOptions` in your project definition (class `TestProject` above):

{{{
    override def compileOptions = Unchecked :: super.compileOptions.toList
}}}

The currently available options for tasks are listed below.

== Compile Options ==

Method `compileOptions` specifies additional options for task `compile` to pass to the Scala compiler.  It has type `Seq[CompileOption]`.  There is a similar method `testCompileOptions` for `test-compile`.  Provided options are:
  * `Deprecation`
  * `Unchecked`
  * `ExplainTypes`
  * `Optimize`
  * `Verbose`
  * `DisableWarnings`
  * `target(t: Target.Value)`   (accepts values of the `Target` enumeration: `Java1_5`, `Java1_4`, `Msil`)
  * `CompileOption(option: String)`   (for arbitrary options)

Method `javaCompileOptions` specifies the options passed to the Java compiler by the `compile` task.  There is a similar method `testJavaCompileOptions` for `test-compile`.  Currently, all options are specified by:
  * `JavaCompileOption(option: String)`

== Run Options ==

Method `mainClass` is of type `Option[String]` and specifies an optional main class to run when the `run` task is invoked.  The default implementation specifies no main class (`None`).  When `mainClass` is not specified, the `run` task will determine which class to run automatically.  If exactly one main class is detected, it is run.  If multiple main classes are detected, the user is prompted for which one to run.

== Package Options ==

If defined, the `mainClass` method specifies the value of the `Main-Class` attribute in the manifest.  The `manifestClassPath`method, if defined, specifies the value of `Class-Path` attribute.  Method `packageOptions` specifies general options for task `package` and is of type `Seq[PackageOption]`.  Provided options are:
  * `MainClass(mainClassName: String)`   Specifies the `Main-Class` attribute in the manifest.  By default, this option is included with the value of the `mainClass` method if it is defined.  When `mainClass` is not specified explicitly, the `package` task will try to determine which class to use automatically.  If exactly one main class is detected, it is used.  If multiple main classes are detected, a warning is printed and no `Main-Class` attribute is added to the manifest.
  * `ManifestAttributes(attributes: (java.util.Attributes.Name, String)*)` or `ManifestAttributes(attributes: (java.util.Attributes.Name, String)*)`   Defines main attributes to add to the manifest.
  * `JarManifest(m: Manifest)`   Specifies the manifest to use for the jar.  The default manifest includes the `Main-Class` attribute if `mainClass` (as described above) is not empty and the `Class-Path` attribute if `manifestClassPath` is not empty.

== Document Options ==

Method `documentOptions` specifies the options for the API documentation tasks `doc` and `docTests`.  Provided options are:
  * `LinkSource`
  * `NoComment`
  * `access(access: Access.Value)`
  * `documentBottom(bottomText: String)`
  * `documentCharset(charset: String)`
  * `documentTitle(title: String)`
  * `documentFooter(footerText: String)`
  * `documentHeader(headerText: String)`
  * `stylesheetFile(path: Path)`
  * `documentTop(topText: String)`
  * `windowTitle(title: String)`

== Test Options ==

Method `testOptions` specifies the options for the `test` action.
  * `ExcludeTests(tests: Iterable[String])`   Specifies the class names of tests that should not be run.
  * `TestFilter(filter: String => Boolean)`  Specifies a function that returns `true` if the test should be run.
  * `TestListeners(listeners: Iterable[TestReportListener])`  Specifies the reporters used when running tests.  `testOptions` by default includes a reporter that sends output to the project logger.

== Dependency Management (Update) Options ==

Method `updateOptions` specifies the options for the dependency management task `update`.  Available options are:
 * `Validate`   Specifying this validates the configuration files (Maven or Ivy).  This is used by default.
 * `Synchronize`   Specifying this removes libraries that are not currently used from the managed library directory.  This is used by default.
 * `QuietUpdate`   Specifying this puts Ivy in quiet mode during execution.  This is used by default.
 * `ErrorIfNoConfiguration`   Specifying this causes the `update` task to fail if no configuration is provided inline or as a file.  Otherwise, it performs no action.  This is not used by default.
 * `AddScalaToolsReleases`   Specifying this adds the `http://scala-tools.org/repo-releases` repository to the configured repositories if `ivysettings.xml` is not present.  This is used by default.
 * `LibraryManager(manager: Manager)`   Explicitly specifies the method to use for handling dependencies.
 * `CacheDirectory(directory: Path)`   Explicitly specifies the directory to use for the download and metadata cache for Ivy.
 * `CheckScalaVersion(configs, checkExplicit, filterImplicit)`   Configures checking and filtering of Scala dependencies.  See [ScalaJars Scala Jars and Dependency Management] for details.

= Changing Paths =

The only paths in `sbt` that are completely fixed are the locations of the files in the `project` directory.  The other paths, such as the path to sources, jars, and outputs, are configurable.  Overriding the default paths is described in this section.  See [Paths] for details on constructing paths.

Paths in `sbt` are incrementally built up out of path components so that you can easily rename any directory in the path or modify the path structure.

The paths and the names used to construct them are defined in `BasicProjectPaths`, which is mixed into the default project definition, as members that you can override.  If you only want to rename a directory, override the member that specifies the name.  For example, to rename the output directory from `target` to `build`,

{{{
  override def outputDirectoryName = "build"
}}}

The outputs for compilation and API documentation are defined as:
{{{
  def outputPath = path(outputDirectoryName)

  def compilePath = outputPath / compileDirectoryName
  def docPath = outputPath / docDirectoryName
  def graphPath = outputPath / graphDirectoryName
  def analysisPath = outputPath / analysisDirectoryName
}}}

and so the directory name will be used by subpaths as well.

Similarly, you could rearrange the source directory from
{{{
src/
  main/
    scala/
    resources/
  test/
    scala/
    resources/
}}}
to
{{{
src/
resources/
test-src/
test-resources/
}}}
by specifying the following in your project definition:
{{{
  override def mainScalaSourcePath = "src"
  override def mainResourcesPath = "resources"
	
  override def testScalaSourcePath = "test-src"
  override def testResourcesPath = "test-resources"
}}}

The paths directly used by the default actions are listed below.  Other paths are only used to build up these paths.  If redefined, care should be taken to keep these paths distinct.
 * `dependencyPath`- This is the location of manually managed jars.
 * `managedDependencyPath` - This is the location that automatic dependency management puts downloaded artifacts.  When executed, the `clean-lib` action removes this directory.
 * `mainScalaSourcePath` - The path to Scala sources comprising the project.
 * `mainJavaSourcePath`: The path to the main Java sources for the project.
 * `mainResourcesPath` - The path to resources to include in the project jar.
 * `testScalaSourcePath` - The path to Scala sources defining tests.
 * `testJavaSourcePath`: The path to the test Java sources for the project.
 * `testResourcesPath` - The path to resources to include in the test jar.
 * `outputPath` - The path containing all `sbt`-generated files (besides the managed artifacts that go in `managedDependencyPath`).  All files generated by tasks should go in this directory.  When executed, the `clean` action removes this directory.  The following are subpaths of `outputPath`:
  * `mainDocPath` - The path where API documentation for main sources goes.
  * `testDocPath` - The path where API documentation for test sources goes.
  * `mainCompilePath` - The path where compiled main classes go.
  * `testCompilePath` - The path where compiled test classes go.
  * `mainAnalysisPath` - The path where the analysis done at compile time goes.  This includes files that record dependencies from the Scala sources.
  * `testAnalysisPath` - The path where the analysis done at test compile time goes.  This includes files that record dependencies from the Scala sources and the class names of tests.

Additionally, web applications use these paths defined in `sbt.WebProjectPaths`:
 * `webappPath` - The location of web application resources.
 * `temporaryWarPath` - The intermediate location used to create a war file or to run Jetty.  It should be a subpath of `outputPath`.
 
Webstart applications use the paths defined in `sbt.WebstartPaths`:
 * `webstartOutputDirectory` - The directory that the webstart products are created in.
 * `webstartMainJar` - The jar that contains the entry point to the application.
 * `webstartLibDirectory` - The directory that libraries will go in.
 * `jnlpFile` - The location in the webstart output directory to write the JNLP XML file to.
 * `webstartZip` - `Some` containing the location to write the zipped output directory to or `None` if no zip of the output directory should be created
 * `jnlpPath` - The directory containing resources to copy to the webstart output directory.
 * `jnlpResourcesPath` - The resources to include in the webstart output directory.  By default this is everything in `jnlpPath`