= Scripted Tests and Change Detection =

A general guideline for a build tool is that you should be able to trust its outputs.  This is especially relevant to compiling Scala sources.  The Scala compiler is slow and so it is desirable to improve its speed.  One simple way `sbt` does this is to run the compiler in the same virtual machine each time.  (Note that this is not quite the same as `fsc`, which reuses the same compiler instance.)  This approach results in a consistent speedup by a factor of 2 after the first compile.

A second way to speed up compilation times is to only recompile sources that are out of date.  This approach requires a lot of work to do properly and will kill your trust in your build when not done properly.  A sign of failure is users running `clean` excessively.  This is the motivation behind `sbt`'s scripted test framework: to try to find bugs in `sbt`'s change detection.

The general idea is to create a test project and a set of changes to make to that project.  You write a script that consists of statements that apply those changes and invoke actions on the project, declaring whether the action should succeed or fail.  Before describing this in further detail, I'll discuss change detection in `sbt`.

== Change Detection ==

There are a few indications that a source has changed:
 # It no longer exists.
 # Its last modified time is newer than a timestamp for when the last compile was done.
 # Its last modified time is newer than the last modified time of one of the classes produces from it.
 # Its SHA or MD5 hash is different from the hash computed when the last compile was done.
 # One of the classes generated from it does not exist anymore.

Once a source is detected as out of date, there are three possibilities:
 # Recompile only the sources directly out of date.
 # Recompile the sources directly out of date and all sources that depend on them.
 # Recompile all sources.

When a source is out of date (directly or indirectly), its classes should be deleted.  This requires tracking every class created by a source.

Through version 0.3.6, sbt has used 1, 3, and 5 combined to detect changes and recompilation strategy 2.  The trunk version substitutes change detection approach 4 (comparing hashes) for approach 3 (comparing last modified times) because of the following problems with approach 3:

 # Changes to a source that produces no classes are not detected (requires 2 or 4)
 # Changes to a source between starting a compilation and finishing it are not detected (requires 2 or 4)
 # The resolution of last modified time can be as coarse as 1 second for many filesystems. (requires 4)

The last issue was especially a problem when implementing the scripted tests.  An automated test script could compile, update, and compile again within a second.  The second compile wouldn't detect any changes because the last modified times were the same.

One problem with hashing is that it reads in every source file to calculate its hash.  As a rough idea, this might take about 1 second per 10 MB of sources on a local filesystem.  This mainly affects how long it takes to run compile on a project without any changes, since a project with 10 MB of Scala sources probably takes several minutes to compile.  Of course, the change detection to use is configurable, so you can use the last modified method if the problems listed above are acceptable.

=== Example ===

As an example, consider the following two definitions:

`A.scala`
{{{
object A {
    val x = B.y
}
}}}

`B.scala`
{{{
object B {
    val y = 5
}
}}}

Now, consider what happens if you were to delete `B.scala`.  When you recompile, you should get an error because `B` no longer exists for `A` to reference.

The first problem occurs if you do not recompile `A.scala`.  This would happen if you do not take source dependencies into account and you only recompile directly modified sources (here, `A.scala` is out of date because it depends on `B.scala`, but `A.scala` is not directly modified).  A solution for a build system without source dependency tracking would be to either recompile all sources.  Alternatively, it could omit `A.scala` from recompilation and consequently require the user to do a full clean and then compile in order to get a proper build.

The second problem is that if you do not delete the classes for `B`, the compiler will still find the classes for `B` in the output directory.  So, there will not be a compiler error even though you have recompiled `A.scala`.


== Scripts ==

=== Syntax ===

{{{
script ::= statement+
statement ::= action | command

action ::= '>' name expected-result
command ::= '$' name argument* expected-result

expected-result ::= '[success]' | '[failure]'
}}}

=== Example ===

{{{
> compile
[success]

$ delete src/main/scala/B.scala
[success]

> compile
[failure]
}}}

=== Commands ===

All paths are relative to the project directory.

`copy-file fromPath toPath`
    Copies the file given by `fromPath` to `toPath`.
`copy fromPath+ toDirectoryPath`
    Copies the files given by `fromPaths` to the `toDirectoryPath` directory.  The directory structure relative to the project directory is preserved.
`sync fromDirectory toDirectory`
    Synchronizes `fromDirectory` and `toDirectory` so that the contents of `toDirectory` are identical to that of `fromDirectory`.
`delete path+`
    Deletes the files given by `path`s.
`touch path+`
    Creates or updates the last modified time of the given `path`s.
`exists path+`
    Succeeds if the given `path`s exist, fails otherwise.
`absent path+`
    Succeeds if the given `path`s do not exist, fails otherwise.