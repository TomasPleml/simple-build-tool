= Artifacts =

== Defining Artifacts ==

By default, the published artifact is a war for `DefaultWebProject` and a jar for `DefaultProject`.  You can declare other types of artifacts to publish by defining `Artifact` instances in your project definition.  Multiple artifacts are allowed.

The basic constructions look like:
{{{
  val art  = Artifact("name", "type", "extension")
  val art2 = Artifact("name", "classifier")
  val art3 = Artifact("name", url: URL)
  val art4 = Artifact("name", Map("extra1" -> "value1", "extra2" -> "value2"))
}}}
For example:
{{{
  val myZip = Artifact("myproject", "zip", "zip")
  val myImg = Artifact("myproject", "image", "jpg")
  val for15 = Artifact("myproject", "jdk15")
}}}

See the [http://ant.apache.org/ivy/history/2.1.0/ivyfile/dependency-artifact.html Ivy documentation] for more details on artifacts.  See the [http://simple-build-tool.googlecode.com/svn/artifacts/latest/api/sbt/Artifact$object.html Artifact API documentation] for combining the parameters above and specifying [ManagedConfigurations configurations] and extra attributes.

=== Details ===

These declarations are collected and are made available under the `artifacts` method of your project definition.  You could alternatively define your artifacts directly by overriding `artifacts`:

{{{
 override def artifacts =
   Artifact("myproject", "zip", "zip") ::
   Artifact("myproject", "jdk15") ::
   Nil
}}}

To specify artifacts directly in addition to reflective definitions as above, add the artifacts to `super.artifacts`:
{{{
 override def artifacts =
   super.artifacts ++ Seq( Artifact("myproject", "zip", "zip") )
}}}

The `artifacts` method is then used to attach the artifacts to the project ID:
{{{
  def projectID =
    ModuleID(organization, moduleID, version.toString) artifacts(artifacts : _*)
}}}

Another alternative is to directly override `projectID` to specify your artifacts.

== Sources/Docs ==

A common need is to publish source and doc artifacts.  The declarations would look like:
{{{
  // make the jar names have the expected format
  override def packageDocsJar = defaultJarPath("-javadoc.jar")
  override def packageSrcJar= defaultJarPath("-sources.jar")

  // define the artifacts
  val sourceArtifact = Artifact(artifactID, "src", "jar", Some("sources"), Nil, None)
  val docsArtifact = Artifact(artifactID, "docs", "jar", Some("javadoc"), Nil, None)
}}}
See [Publishing] for the full details on publishing sources and docs.

== Using Dependencies with Artifacts ==

To specify the artifacts to use from a dependency that has custom or multiple artifacts, use the `artifacts` method on your dependencies.  For example:

{{{
  val dep = "org" % "name" % "rev" artifacts(Artifact("name", "type", "ext"))
}}}

The `from` and `classifer` methods (described on the [http://code.google.com/p/simple-build-tool/wiki/LibraryManagement Basics page]) are actually convenience methods that translate to `artifacts`:

{{{
  def from(url: String) = artifacts( Artifact(name, new URL(url)) )
  def classifier(c: String) = artifacts( Artifact(name, c) )
}}}

That is, the following two dependency declarations are equivalent:
{{{
 val testng = "org.testng" % "testng" % "5.7" classifier "jdk15"
 val testng = "org.testng" % "testng" % "5.7" artifacts( Artifact("testng", "jdk15") )
}}}